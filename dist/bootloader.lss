
./dist/bootloader.bin:     file format elf32-avr


Disassembly of section .text:

00007000 <__vectors>:
    7000:	0c 94 34 38 	jmp	0x7068	; 0x7068 <__ctors_end>
    7004:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7008:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    700c:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7010:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7014:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7018:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    701c:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7020:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7024:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7028:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    702c:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7030:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7034:	0c 94 5e 39 	jmp	0x72bc	; 0x72bc <__vector_13>
    7038:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    703c:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7040:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7044:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7048:	0c 94 90 38 	jmp	0x7120	; 0x7120 <__vector_18>
    704c:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7050:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7054:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7058:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    705c:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7060:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>
    7064:	0c 94 51 38 	jmp	0x70a2	; 0x70a2 <__bad_interrupt>

00007068 <__ctors_end>:
    7068:	11 24       	eor	r1, r1
    706a:	1f be       	out	0x3f, r1	; 63
    706c:	cf ef       	ldi	r28, 0xFF	; 255
    706e:	d8 e0       	ldi	r29, 0x08	; 8
    7070:	de bf       	out	0x3e, r29	; 62
    7072:	cd bf       	out	0x3d, r28	; 61

00007074 <__do_copy_data>:
    7074:	11 e0       	ldi	r17, 0x01	; 1
    7076:	a0 e0       	ldi	r26, 0x00	; 0
    7078:	b1 e0       	ldi	r27, 0x01	; 1
    707a:	e8 e9       	ldi	r30, 0x98	; 152
    707c:	f6 e7       	ldi	r31, 0x76	; 118
    707e:	02 c0       	rjmp	.+4      	; 0x7084 <__do_copy_data+0x10>
    7080:	05 90       	lpm	r0, Z+
    7082:	0d 92       	st	X+, r0
    7084:	a8 3c       	cpi	r26, 0xC8	; 200
    7086:	b1 07       	cpc	r27, r17
    7088:	d9 f7       	brne	.-10     	; 0x7080 <__do_copy_data+0xc>

0000708a <__do_clear_bss>:
    708a:	22 e0       	ldi	r18, 0x02	; 2
    708c:	a8 ec       	ldi	r26, 0xC8	; 200
    708e:	b1 e0       	ldi	r27, 0x01	; 1
    7090:	01 c0       	rjmp	.+2      	; 0x7094 <.do_clear_bss_start>

00007092 <.do_clear_bss_loop>:
    7092:	1d 92       	st	X+, r1

00007094 <.do_clear_bss_start>:
    7094:	ab 37       	cpi	r26, 0x7B	; 123
    7096:	b2 07       	cpc	r27, r18
    7098:	e1 f7       	brne	.-8      	; 0x7092 <.do_clear_bss_loop>
    709a:	0e 94 e9 39 	call	0x73d2	; 0x73d2 <main>
    709e:	0c 94 4a 3b 	jmp	0x7694	; 0x7694 <_exit>

000070a2 <__bad_interrupt>:
    70a2:	0c 94 00 38 	jmp	0x7000	; 0x7000 <__vectors>

000070a6 <bufferEmpty>:
	UCSR0B = 0x0;
	UCSR0C = 0x6; // 0 0 0 0 0 1 1 0
}

uint8_t bufferEmpty() {
	return (!counter);
    70a6:	90 91 d2 01 	lds	r25, 0x01D2	; 0x8001d2 <counter>
    70aa:	81 e0       	ldi	r24, 0x01	; 1
    70ac:	91 11       	cpse	r25, r1
    70ae:	80 e0       	ldi	r24, 0x00	; 0
}
    70b0:	08 95       	ret

000070b2 <uart_send>:

void uart_send(uint8_t data) {
	
	// If send register empty and no XOFF
	while(!(UCSR0A & (1<<UDRE0)) && !sendBlock) {
    70b2:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
    70b6:	95 fd       	sbrc	r25, 5
    70b8:	04 c0       	rjmp	.+8      	; 0x70c2 <uart_send+0x10>
    70ba:	90 91 d1 01 	lds	r25, 0x01D1	; 0x8001d1 <sendBlock>
    70be:	99 23       	and	r25, r25
    70c0:	c1 f3       	breq	.-16     	; 0x70b2 <uart_send>
		;
	}
	UDR0 = data;
    70c2:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
    70c6:	08 95       	ret

000070c8 <clearScreen>:
	}
}

void clearScreen(){
	// Clear terminal
	uart_send(27); // ESC
    70c8:	8b e1       	ldi	r24, 0x1B	; 27
    70ca:	0e 94 59 38 	call	0x70b2	; 0x70b2 <uart_send>
	uart_send('[');
    70ce:	8b e5       	ldi	r24, 0x5B	; 91
    70d0:	0e 94 59 38 	call	0x70b2	; 0x70b2 <uart_send>
	uart_send('2');
    70d4:	82 e3       	ldi	r24, 0x32	; 50
    70d6:	0e 94 59 38 	call	0x70b2	; 0x70b2 <uart_send>
	uart_send('J');
    70da:	8a e4       	ldi	r24, 0x4A	; 74
    70dc:	0e 94 59 38 	call	0x70b2	; 0x70b2 <uart_send>

	// Move cursor to start
	uart_send(27);
    70e0:	8b e1       	ldi	r24, 0x1B	; 27
    70e2:	0e 94 59 38 	call	0x70b2	; 0x70b2 <uart_send>
	uart_send('[');
    70e6:	8b e5       	ldi	r24, 0x5B	; 91
    70e8:	0e 94 59 38 	call	0x70b2	; 0x70b2 <uart_send>
	uart_send('H');
    70ec:	88 e4       	ldi	r24, 0x48	; 72
    70ee:	0c 94 59 38 	jmp	0x70b2	; 0x70b2 <uart_send>

000070f2 <uart_init>:
}

void uart_init() {
	// Configure baud rate
	UBRR0H = (BAUD_CONST >> 8);
    70f2:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
	UBRR0L = BAUD_CONST;
    70f6:	87 e6       	ldi	r24, 0x67	; 103
    70f8:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
	
	// Enable uart send and receive and uart receive complete interrupt
	UCSR0B |= ((1<<RXEN0) | (1<<TXEN0) | (1<<RXCIE0));
    70fc:	e1 ec       	ldi	r30, 0xC1	; 193
    70fe:	f0 e0       	ldi	r31, 0x00	; 0
    7100:	80 81       	ld	r24, Z
    7102:	88 69       	ori	r24, 0x98	; 152
    7104:	80 83       	st	Z, r24

    clearScreen();
    7106:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <clearScreen>

0000710a <send_xoff>:
	}

	return returnVal;
}

void send_xoff(){
    710a:	cf 93       	push	r28
	uint8_t sreg = SREG;
    710c:	cf b7       	in	r28, 0x3f	; 63
	cli();
    710e:	f8 94       	cli
	x_status = XOFF;
    7110:	83 e1       	ldi	r24, 0x13	; 19
    7112:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <x_status>
	uart_send(XOFF);
    7116:	0e 94 59 38 	call	0x70b2	; 0x70b2 <uart_send>
	SREG = sreg;
    711a:	cf bf       	out	0x3f, r28	; 63
	
}
    711c:	cf 91       	pop	r28
    711e:	08 95       	ret

00007120 <__vector_18>:
volatile uint8_t lastRead = 0;
volatile uint8_t counter = 0;
volatile uint8_t sendBlock = 0;
volatile uint8_t x_status = XON; 

ISR(USART_RX_vect){
    7120:	1f 92       	push	r1
    7122:	0f 92       	push	r0
    7124:	0f b6       	in	r0, 0x3f	; 63
    7126:	0f 92       	push	r0
    7128:	11 24       	eor	r1, r1
    712a:	2f 93       	push	r18
    712c:	3f 93       	push	r19
    712e:	4f 93       	push	r20
    7130:	5f 93       	push	r21
    7132:	6f 93       	push	r22
    7134:	7f 93       	push	r23
    7136:	8f 93       	push	r24
    7138:	9f 93       	push	r25
    713a:	af 93       	push	r26
    713c:	bf 93       	push	r27
    713e:	ef 93       	push	r30
    7140:	ff 93       	push	r31
	uint8_t tmp = UDR0;
    7142:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
	
	// If XOFF is received block sending
	if (tmp == XOFF) {
    7146:	83 31       	cpi	r24, 0x13	; 19
    7148:	21 f4       	brne	.+8      	; 0x7152 <__vector_18+0x32>
		sendBlock = 1;
    714a:	81 e0       	ldi	r24, 0x01	; 1
    714c:	80 93 d1 01 	sts	0x01D1, r24	; 0x8001d1 <sendBlock>
    7150:	22 c0       	rjmp	.+68     	; 0x7196 <__vector_18+0x76>
	} 
	// if XON is received allow sending
	else if(tmp == XON) {
    7152:	81 31       	cpi	r24, 0x11	; 17
    7154:	19 f4       	brne	.+6      	; 0x715c <__vector_18+0x3c>
		sendBlock = 0;
    7156:	10 92 d1 01 	sts	0x01D1, r1	; 0x8001d1 <sendBlock>
    715a:	1d c0       	rjmp	.+58     	; 0x7196 <__vector_18+0x76>
	}
	else {
		receiveBuffer[lastReceived] = tmp;
    715c:	e0 91 d4 01 	lds	r30, 0x01D4	; 0x8001d4 <lastReceived>
    7160:	f0 e0       	ldi	r31, 0x00	; 0
    7162:	eb 52       	subi	r30, 0x2B	; 43
    7164:	fe 4f       	sbci	r31, 0xFE	; 254
    7166:	80 83       	st	Z, r24
		lastReceived = ((lastReceived + 1) % 32);
    7168:	80 91 d4 01 	lds	r24, 0x01D4	; 0x8001d4 <lastReceived>
    716c:	90 e0       	ldi	r25, 0x00	; 0
    716e:	01 96       	adiw	r24, 0x01	; 1
    7170:	8f 71       	andi	r24, 0x1F	; 31
    7172:	99 27       	eor	r25, r25
    7174:	80 93 d4 01 	sts	0x01D4, r24	; 0x8001d4 <lastReceived>
		counter++;
    7178:	80 91 d2 01 	lds	r24, 0x01D2	; 0x8001d2 <counter>
    717c:	8f 5f       	subi	r24, 0xFF	; 255
    717e:	80 93 d2 01 	sts	0x01D2, r24	; 0x8001d2 <counter>
		// If ring buffer has 26 elements stop receiving
		if(counter >= 22 && x_status==XON) {
    7182:	80 91 d2 01 	lds	r24, 0x01D2	; 0x8001d2 <counter>
    7186:	86 31       	cpi	r24, 0x16	; 22
    7188:	30 f0       	brcs	.+12     	; 0x7196 <__vector_18+0x76>
    718a:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <x_status>
    718e:	81 31       	cpi	r24, 0x11	; 17
    7190:	11 f4       	brne	.+4      	; 0x7196 <__vector_18+0x76>
			send_xoff();
    7192:	0e 94 85 38 	call	0x710a	; 0x710a <send_xoff>
		}
	}
}
    7196:	ff 91       	pop	r31
    7198:	ef 91       	pop	r30
    719a:	bf 91       	pop	r27
    719c:	af 91       	pop	r26
    719e:	9f 91       	pop	r25
    71a0:	8f 91       	pop	r24
    71a2:	7f 91       	pop	r23
    71a4:	6f 91       	pop	r22
    71a6:	5f 91       	pop	r21
    71a8:	4f 91       	pop	r20
    71aa:	3f 91       	pop	r19
    71ac:	2f 91       	pop	r18
    71ae:	0f 90       	pop	r0
    71b0:	0f be       	out	0x3f, r0	; 63
    71b2:	0f 90       	pop	r0
    71b4:	1f 90       	pop	r1
    71b6:	18 95       	reti

000071b8 <send_xon>:
	x_status = XOFF;
	uart_send(XOFF);
	SREG = sreg;
	
}
void send_xon(){
    71b8:	cf 93       	push	r28
	uint8_t sreg = SREG;
    71ba:	cf b7       	in	r28, 0x3f	; 63
	cli();
    71bc:	f8 94       	cli
	x_status = XON;
    71be:	81 e1       	ldi	r24, 0x11	; 17
    71c0:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <x_status>
	uart_send(XON);
    71c4:	0e 94 59 38 	call	0x70b2	; 0x70b2 <uart_send>
	SREG = sreg;
    71c8:	cf bf       	out	0x3f, r28	; 63
}
    71ca:	cf 91       	pop	r28
    71cc:	08 95       	ret

000071ce <uart_receive>:
		;
	}
	UDR0 = data;
}

uint8_t uart_receive(){
    71ce:	cf 93       	push	r28
	UCSR0B = 0x0;
	UCSR0C = 0x6; // 0 0 0 0 0 1 1 0
}

uint8_t bufferEmpty() {
	return (!counter);
    71d0:	80 91 d2 01 	lds	r24, 0x01D2	; 0x8001d2 <counter>
	}
	UDR0 = data;
}

uint8_t uart_receive(){
	if(bufferEmpty()) {
    71d4:	88 23       	and	r24, r24
    71d6:	f1 f0       	breq	.+60     	; 0x7214 <uart_receive+0x46>
		return '\0';
	}
	
	uint8_t returnVal = receiveBuffer[lastRead];	
    71d8:	e0 91 d3 01 	lds	r30, 0x01D3	; 0x8001d3 <lastRead>
    71dc:	f0 e0       	ldi	r31, 0x00	; 0
    71de:	eb 52       	subi	r30, 0x2B	; 43
    71e0:	fe 4f       	sbci	r31, 0xFE	; 254
    71e2:	c0 81       	ld	r28, Z
	counter--;
    71e4:	80 91 d2 01 	lds	r24, 0x01D2	; 0x8001d2 <counter>
    71e8:	81 50       	subi	r24, 0x01	; 1
    71ea:	80 93 d2 01 	sts	0x01D2, r24	; 0x8001d2 <counter>
	lastRead = (lastRead + 1) % 32;
    71ee:	80 91 d3 01 	lds	r24, 0x01D3	; 0x8001d3 <lastRead>
    71f2:	90 e0       	ldi	r25, 0x00	; 0
    71f4:	01 96       	adiw	r24, 0x01	; 1
    71f6:	8f 71       	andi	r24, 0x1F	; 31
    71f8:	99 27       	eor	r25, r25
    71fa:	80 93 d3 01 	sts	0x01D3, r24	; 0x8001d3 <lastRead>
	
	// If ring buffer elements are less than or equal to 10 allow sending
	if (counter <= 10 && x_status == XOFF) {
    71fe:	80 91 d2 01 	lds	r24, 0x01D2	; 0x8001d2 <counter>
    7202:	8b 30       	cpi	r24, 0x0B	; 11
    7204:	30 f4       	brcc	.+12     	; 0x7212 <uart_receive+0x44>
    7206:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <x_status>
    720a:	83 31       	cpi	r24, 0x13	; 19
    720c:	11 f4       	brne	.+4      	; 0x7212 <uart_receive+0x44>
		send_xon();
    720e:	0e 94 dc 38 	call	0x71b8	; 0x71b8 <send_xon>
	uint8_t returnVal = receiveBuffer[lastRead];	
	counter--;
	lastRead = (lastRead + 1) % 32;
	
	// If ring buffer elements are less than or equal to 10 allow sending
	if (counter <= 10 && x_status == XOFF) {
    7212:	8c 2f       	mov	r24, r28
		send_xon();
	}

	return returnVal;
}
    7214:	cf 91       	pop	r28
    7216:	08 95       	ret

00007218 <sendCRLF>:
	uart_send(XON);
	SREG = sreg;
}

void sendCRLF(){
    uart_send(0x0D);
    7218:	8d e0       	ldi	r24, 0x0D	; 13
    721a:	0e 94 59 38 	call	0x70b2	; 0x70b2 <uart_send>
    uart_send(0x0A);
    721e:	8a e0       	ldi	r24, 0x0A	; 10
    7220:	0c 94 59 38 	jmp	0x70b2	; 0x70b2 <uart_send>

00007224 <sendString>:
}

void sendString(char * string){
    7224:	0f 93       	push	r16
    7226:	1f 93       	push	r17
    7228:	cf 93       	push	r28
    722a:	8c 01       	movw	r16, r24
    uint8_t index = 0;
    722c:	c0 e0       	ldi	r28, 0x00	; 0

    while(string[index] != 0){
    722e:	f8 01       	movw	r30, r16
    7230:	ec 0f       	add	r30, r28
    7232:	f1 1d       	adc	r31, r1
    7234:	80 81       	ld	r24, Z
    7236:	88 23       	and	r24, r24
    7238:	21 f0       	breq	.+8      	; 0x7242 <sendString+0x1e>
        uart_send(string[index]);
    723a:	0e 94 59 38 	call	0x70b2	; 0x70b2 <uart_send>
        index++;
    723e:	cf 5f       	subi	r28, 0xFF	; 255
    7240:	f6 cf       	rjmp	.-20     	; 0x722e <sendString+0xa>
    }   
}
    7242:	cf 91       	pop	r28
    7244:	1f 91       	pop	r17
    7246:	0f 91       	pop	r16
    7248:	08 95       	ret

0000724a <uart_deinit>:

    clearScreen();
}

void uart_deinit() {
	clearScreen();
    724a:	0e 94 64 38 	call	0x70c8	; 0x70c8 <clearScreen>
	sendString("Booting program...");
    724e:	82 e0       	ldi	r24, 0x02	; 2
    7250:	91 e0       	ldi	r25, 0x01	; 1
    7252:	0e 94 12 39 	call	0x7224	; 0x7224 <sendString>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    7256:	2f ef       	ldi	r18, 0xFF	; 255
    7258:	89 e6       	ldi	r24, 0x69	; 105
    725a:	98 e1       	ldi	r25, 0x18	; 24
    725c:	21 50       	subi	r18, 0x01	; 1
    725e:	80 40       	sbci	r24, 0x00	; 0
    7260:	90 40       	sbci	r25, 0x00	; 0
    7262:	e1 f7       	brne	.-8      	; 0x725c <uart_deinit+0x12>
    7264:	00 c0       	rjmp	.+0      	; 0x7266 <uart_deinit+0x1c>
    7266:	00 00       	nop
	_delay_ms(500);
    clearScreen();
    7268:	0e 94 64 38 	call	0x70c8	; 0x70c8 <clearScreen>
    726c:	2f ef       	ldi	r18, 0xFF	; 255
    726e:	81 ee       	ldi	r24, 0xE1	; 225
    7270:	94 e0       	ldi	r25, 0x04	; 4
    7272:	21 50       	subi	r18, 0x01	; 1
    7274:	80 40       	sbci	r24, 0x00	; 0
    7276:	90 40       	sbci	r25, 0x00	; 0
    7278:	e1 f7       	brne	.-8      	; 0x7272 <uart_deinit+0x28>
    727a:	00 c0       	rjmp	.+0      	; 0x727c <uart_deinit+0x32>
    727c:	00 00       	nop
	_delay_ms(100);
	// Reset registers
	UBRR0H = 0x0;
    727e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
	UBRR0L = 0x0;
    7282:	10 92 c4 00 	sts	0x00C4, r1	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>

	UDR0 = 0x0;
    7286:	10 92 c6 00 	sts	0x00C6, r1	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
	UCSR0A = 0x20; // 0 0 1 0 0 0 0 0
    728a:	80 e2       	ldi	r24, 0x20	; 32
    728c:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
	UCSR0B = 0x0;
    7290:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
	UCSR0C = 0x6; // 0 0 0 0 0 1 1 0
    7294:	86 e0       	ldi	r24, 0x06	; 6
    7296:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
    729a:	08 95       	ret

0000729c <runProgram>:
    }
}

void runProgram(){
    // clear timer
    TCCR1B = 0x0;
    729c:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
    TCNT1 = 0x0;
    72a0:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
    72a4:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
    TIMSK1 = 0x0;
    72a8:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
	
	//Move back to the normal Interrupt vector
	MCUCR = (1<<IVCE);
    72ac:	81 e0       	ldi	r24, 0x01	; 1
    72ae:	85 bf       	out	0x35, r24	; 53
	MCUCR = 0;
    72b0:	15 be       	out	0x35, r1	; 53

    // Disable interrupts
	cli();
    72b2:	f8 94       	cli
	
    // Reset Uart
    uart_deinit();
    72b4:	0e 94 25 39 	call	0x724a	; 0x724a <uart_deinit>
	
    // Jump into the program
    goto*(0x0);
    72b8:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>

000072bc <__vector_13>:

/* Reset every cell of the data buffer to contain 0xFF */
void resetDataBuffer();

/* This Timer runs 4 seconds in order to signal a the timeout*/
ISR(TIMER1_OVF_vect){
    72bc:	1f 92       	push	r1
    72be:	0f 92       	push	r0
    72c0:	0f b6       	in	r0, 0x3f	; 63
    72c2:	0f 92       	push	r0
    72c4:	11 24       	eor	r1, r1
    runProgram();
    72c6:	0e 94 4e 39 	call	0x729c	; 0x729c <runProgram>

000072ca <resetDataBuffer>:
	dataIndex = 0;
	resetDataBuffer();
    send_xon();
}

void resetDataBuffer() {
    72ca:	e6 ef       	ldi	r30, 0xF6	; 246
    72cc:	f1 e0       	ldi	r31, 0x01	; 1
	for (uint8_t i = 0; i < SPM_PAGESIZE; i++) {
		data[i] = 0xFF;
    72ce:	8f ef       	ldi	r24, 0xFF	; 255
	resetDataBuffer();
    send_xon();
}

void resetDataBuffer() {
	for (uint8_t i = 0; i < SPM_PAGESIZE; i++) {
    72d0:	92 e0       	ldi	r25, 0x02	; 2
    72d2:	e6 37       	cpi	r30, 0x76	; 118
    72d4:	f9 07       	cpc	r31, r25
    72d6:	11 f0       	breq	.+4      	; 0x72dc <resetDataBuffer+0x12>
		data[i] = 0xFF;
    72d8:	81 93       	st	Z+, r24
    72da:	fa cf       	rjmp	.-12     	; 0x72d0 <resetDataBuffer+0x6>
	}
}
    72dc:	08 95       	ret

000072de <boot_program_page>:

void boot_program_page(uint16_t page, uint8_t *buf){
    72de:	cf 93       	push	r28
    72e0:	df 93       	push	r29
    // Because we calculate pageNumbers we need to get the corresponding address
    page = page * SPM_PAGESIZE;
    72e2:	96 95       	lsr	r25
    72e4:	98 2f       	mov	r25, r24
    72e6:	88 27       	eor	r24, r24
    72e8:	97 95       	ror	r25
    72ea:	87 95       	ror	r24
    uint8_t sreg;

    // Disable interrupts
    sreg = SREG;
    72ec:	5f b7       	in	r21, 0x3f	; 63
    cli();
    72ee:	f8 94       	cli

    // Wait until the memory is erased
    eeprom_busy_wait();
    72f0:	f9 99       	sbic	0x1f, 1	; 31
    72f2:	fe cf       	rjmp	.-4      	; 0x72f0 <boot_program_page+0x12>
    boot_page_erase(page);
    72f4:	23 e0       	ldi	r18, 0x03	; 3
    72f6:	fc 01       	movw	r30, r24
    72f8:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7f8057>
    72fc:	e8 95       	spm
    boot_spm_busy_wait();      
    72fe:	07 b6       	in	r0, 0x37	; 55
    7300:	00 fc       	sbrc	r0, 0
    7302:	fd cf       	rjmp	.-6      	; 0x72fe <boot_program_page+0x20>
    7304:	db 01       	movw	r26, r22
    7306:	40 e0       	ldi	r20, 0x00	; 0
    for(uint8_t i = 0 ; i < SPM_PAGESIZE; i += 2){
        // Set up little-endian word.
        uint16_t w = *buf++;
        w += (*buf++) << 8;
    
        boot_page_fill (page + i, w);
    7308:	61 e0       	ldi	r22, 0x01	; 1
    730a:	ec 01       	movw	r28, r24
    730c:	ca 1b       	sub	r28, r26
    730e:	db 0b       	sbc	r29, r27
    boot_page_erase(page);
    boot_spm_busy_wait();      

    for(uint8_t i = 0 ; i < SPM_PAGESIZE; i += 2){
        // Set up little-endian word.
        uint16_t w = *buf++;
    7310:	7c 91       	ld	r23, X
        w += (*buf++) << 8;
    
        boot_page_fill (page + i, w);
    7312:	fe 01       	movw	r30, r28
    7314:	ea 0f       	add	r30, r26
    7316:	fb 1f       	adc	r31, r27
    7318:	11 96       	adiw	r26, 0x01	; 1
    731a:	2c 91       	ld	r18, X
    731c:	11 97       	sbiw	r26, 0x01	; 1
    731e:	30 e0       	ldi	r19, 0x00	; 0
    7320:	32 2f       	mov	r19, r18
    7322:	22 27       	eor	r18, r18
    7324:	27 0f       	add	r18, r23
    7326:	31 1d       	adc	r19, r1
    7328:	09 01       	movw	r0, r18
    732a:	60 93 57 00 	sts	0x0057, r22	; 0x800057 <__TEXT_REGION_LENGTH__+0x7f8057>
    732e:	e8 95       	spm
    7330:	11 24       	eor	r1, r1
    // Wait until the memory is erased
    eeprom_busy_wait();
    boot_page_erase(page);
    boot_spm_busy_wait();      

    for(uint8_t i = 0 ; i < SPM_PAGESIZE; i += 2){
    7332:	4e 5f       	subi	r20, 0xFE	; 254
    7334:	12 96       	adiw	r26, 0x02	; 2
    7336:	40 38       	cpi	r20, 0x80	; 128
    7338:	59 f7       	brne	.-42     	; 0x7310 <boot_program_page+0x32>
    
        boot_page_fill (page + i, w);
    }

    // Store buffer in flash page
    boot_page_write(page);
    733a:	25 e0       	ldi	r18, 0x05	; 5
    733c:	fc 01       	movw	r30, r24
    733e:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7f8057>
    7342:	e8 95       	spm
    // Wait until the memory is written     
    boot_spm_busy_wait();       
    7344:	07 b6       	in	r0, 0x37	; 55
    7346:	00 fc       	sbrc	r0, 0
    7348:	fd cf       	rjmp	.-6      	; 0x7344 <boot_program_page+0x66>
    // Reenable RWW-section again. We need this if we want to jump back
    // to the application after bootloading
    boot_rww_enable();
    734a:	81 e1       	ldi	r24, 0x11	; 17
    734c:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7f8057>
    7350:	e8 95       	spm
    // Re-enable interrupts (if they were ever enabled).
    SREG = sreg;
    7352:	5f bf       	out	0x3f, r21	; 63
}
    7354:	df 91       	pop	r29
    7356:	cf 91       	pop	r28
    7358:	08 95       	ret

0000735a <programFlash>:
    // Jump into the program
    goto*(0x0);
}

void programFlash(){
	send_xoff();
    735a:	0e 94 85 38 	call	0x710a	; 0x710a <send_xoff>
    735e:	2f ef       	ldi	r18, 0xFF	; 255
    7360:	89 ef       	ldi	r24, 0xF9	; 249
    7362:	90 e0       	ldi	r25, 0x00	; 0
    7364:	21 50       	subi	r18, 0x01	; 1
    7366:	80 40       	sbci	r24, 0x00	; 0
    7368:	90 40       	sbci	r25, 0x00	; 0
    736a:	e1 f7       	brne	.-8      	; 0x7364 <programFlash+0xa>
    736c:	00 c0       	rjmp	.+0      	; 0x736e <programFlash+0x14>
    736e:	00 00       	nop
	_delay_ms(20);
	boot_program_page(currentPage, data);
    7370:	66 ef       	ldi	r22, 0xF6	; 246
    7372:	71 e0       	ldi	r23, 0x01	; 1
    7374:	80 91 c8 01 	lds	r24, 0x01C8	; 0x8001c8 <__data_end>
    7378:	90 91 c9 01 	lds	r25, 0x01C9	; 0x8001c9 <__data_end+0x1>
    737c:	0e 94 6f 39 	call	0x72de	; 0x72de <boot_program_page>
	dataIndex = 0;
    7380:	10 92 d0 01 	sts	0x01D0, r1	; 0x8001d0 <dataIndex>
	resetDataBuffer();
    7384:	0e 94 65 39 	call	0x72ca	; 0x72ca <resetDataBuffer>
    send_xon();
    7388:	0c 94 dc 38 	jmp	0x71b8	; 0x71b8 <send_xon>

0000738c <hexDec>:
    // Re-enable interrupts (if they were ever enabled).
    SREG = sreg;
}

/* Converts 4-Byte Hex String into uint16_t and 2-Byte Hex String into uint8_t */
uint16_t hexDec(uint8_t *bytes, uint8_t num){
    738c:	48 2f       	mov	r20, r24
    uint16_t ret = 0;
    uint8_t c;
    for(uint8_t i = 0; i < num; i++){
    738e:	fc 01       	movw	r30, r24
    SREG = sreg;
}

/* Converts 4-Byte Hex String into uint16_t and 2-Byte Hex String into uint8_t */
uint16_t hexDec(uint8_t *bytes, uint8_t num){
    uint16_t ret = 0;
    7390:	20 e0       	ldi	r18, 0x00	; 0
    7392:	30 e0       	ldi	r19, 0x00	; 0
    uint8_t c;
    for(uint8_t i = 0; i < num; i++){
    7394:	8e 2f       	mov	r24, r30
    7396:	84 1b       	sub	r24, r20
    7398:	86 17       	cp	r24, r22
    739a:	c8 f4       	brcc	.+50     	; 0x73ce <hexDec+0x42>
        c = bytes[i];
    739c:	91 91       	ld	r25, Z+
        if(c >= '0' && c <= '9'){
    739e:	80 ed       	ldi	r24, 0xD0	; 208
    73a0:	89 0f       	add	r24, r25
    73a2:	8a 30       	cpi	r24, 0x0A	; 10
    73a4:	60 f0       	brcs	.+24     	; 0x73be <hexDec+0x32>
            c -= '0';
        } else if (c >= 'A' && c <= 'F'){
    73a6:	8f eb       	ldi	r24, 0xBF	; 191
    73a8:	89 0f       	add	r24, r25
    73aa:	86 30       	cpi	r24, 0x06	; 6
    73ac:	10 f4       	brcc	.+4      	; 0x73b2 <hexDec+0x26>
            c -= ('A' - 10);
    73ae:	97 53       	subi	r25, 0x37	; 55
    73b0:	07 c0       	rjmp	.+14     	; 0x73c0 <hexDec+0x34>
        } else if (c >= 'a' && c <= 'f'){
    73b2:	8f e9       	ldi	r24, 0x9F	; 159
    73b4:	89 0f       	add	r24, r25
    73b6:	86 30       	cpi	r24, 0x06	; 6
    73b8:	18 f4       	brcc	.+6      	; 0x73c0 <hexDec+0x34>
            c -= ('a' - 10);
    73ba:	97 55       	subi	r25, 0x57	; 87
    73bc:	01 c0       	rjmp	.+2      	; 0x73c0 <hexDec+0x34>
    73be:	98 2f       	mov	r25, r24
        }
        ret = (ret << 4) | c;
    73c0:	84 e0       	ldi	r24, 0x04	; 4
    73c2:	22 0f       	add	r18, r18
    73c4:	33 1f       	adc	r19, r19
    73c6:	8a 95       	dec	r24
    73c8:	e1 f7       	brne	.-8      	; 0x73c2 <hexDec+0x36>
    73ca:	29 2b       	or	r18, r25
    73cc:	e3 cf       	rjmp	.-58     	; 0x7394 <hexDec+0x8>
    } 
    return ret;
}
    73ce:	c9 01       	movw	r24, r18
    73d0:	08 95       	ret

000073d2 <main>:
/* number of the page that is currently filled */
uint16_t currentPage = 0;

int main(){
    // Disable interrupts just to be sure
    cli();
    73d2:	f8 94       	cli

    // Activate the bootloader Interrupt Vectors
    uint8_t temp = MCUCR;
    73d4:	85 b7       	in	r24, 0x35	; 53
    MCUCR = temp | (1<<IVCE);
    73d6:	98 2f       	mov	r25, r24
    73d8:	91 60       	ori	r25, 0x01	; 1
    73da:	95 bf       	out	0x35, r25	; 53
    MCUCR = temp | (1<<IVSEL);
    73dc:	82 60       	ori	r24, 0x02	; 2
    73de:	85 bf       	out	0x35, r24	; 53

    // Setup UART
    uart_init();
    73e0:	0e 94 79 38 	call	0x70f2	; 0x70f2 <uart_init>
    sendString("Arduino Pro Mini Bootloader by Fabian Becker & Florian Remberger");
    73e4:	85 e1       	ldi	r24, 0x15	; 21
    73e6:	91 e0       	ldi	r25, 0x01	; 1
    73e8:	0e 94 12 39 	call	0x7224	; 0x7224 <sendString>
    sendCRLF();
    73ec:	0e 94 0c 39 	call	0x7218	; 0x7218 <sendCRLF>
    sendString("<p> -> flashing mode | <any key> -> return to application");
    73f0:	86 e5       	ldi	r24, 0x56	; 86
    73f2:	91 e0       	ldi	r25, 0x01	; 1
    73f4:	0e 94 12 39 	call	0x7224	; 0x7224 <sendString>
    sendCRLF();
    73f8:	0e 94 0c 39 	call	0x7218	; 0x7218 <sendCRLF>

    // Setup Timer1 to run (4 secs.) -> prescaler 1024
    TCCR1B |= ((1 << CS12) | (1 << CS10));
    73fc:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
    7400:	85 60       	ori	r24, 0x05	; 5
    7402:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
    // 65536 - 62500
    TCNT1 = 3036;
    7406:	8c ed       	ldi	r24, 0xDC	; 220
    7408:	9b e0       	ldi	r25, 0x0B	; 11
    740a:	90 93 85 00 	sts	0x0085, r25	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
    740e:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
    TIMSK1 = (1 << TOIE1);
    7412:	81 e0       	ldi	r24, 0x01	; 1
    7414:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>

    sei();
    7418:	78 94       	sei

    // Mode selection 
    uint8_t c;
    while((c = uart_receive()) == '\0') ;
    741a:	0e 94 e7 38 	call	0x71ce	; 0x71ce <uart_receive>
    741e:	88 23       	and	r24, r24
    7420:	e1 f3       	breq	.-8      	; 0x741a <main+0x48>
	
    if(c != 'p'){
    7422:	80 37       	cpi	r24, 0x70	; 112
    7424:	11 f0       	breq	.+4      	; 0x742a <main+0x58>
        runProgram();
    7426:	0e 94 4e 39 	call	0x729c	; 0x729c <runProgram>
    }

    // Disable Timer
    TCCR1B = 0x0;
    742a:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>

    // Receive program data from serial
    sendString("Please enter .hex code");
    742e:	80 e9       	ldi	r24, 0x90	; 144
    7430:	91 e0       	ldi	r25, 0x01	; 1
    7432:	0e 94 12 39 	call	0x7224	; 0x7224 <sendString>
    sendCRLF();
    7436:	0e 94 0c 39 	call	0x7218	; 0x7218 <sendCRLF>
	
	// Initialize Data Buffer
	resetDataBuffer();
    743a:	0e 94 65 39 	call	0x72ca	; 0x72ca <resetDataBuffer>
							currentPage++;
						}
						
                        if(currentDataLength == dataLength){
							currentDataLength = 0;
                            state = GET_CHECKSUM;
    743e:	06 e0       	ldi	r16, 0x06	; 6
						} 
						runProgram();
					}
                    
                    bytesReceived = 0;
                    state = WAIT_FOR_START;
    7440:	11 e0       	ldi	r17, 0x01	; 1
                    // Calculate checksum -> build 2th's complement and check for equality
                    byteSum = ~byteSum + 1;
					
					if(byteSum != checksum){
						sendString("Checksum mismatch. Please Reset!");
						state = CHECKSUM_ERROR;
    7442:	97 e0       	ldi	r25, 0x07	; 7
    7444:	f9 2e       	mov	r15, r25
                    // Add up Bytes for checksum
                    byteSum += dataLength;

                    // Reset for next state
                    bytesReceived = 0;
                    state = GET_ADDRESS;
    7446:	23 e0       	ldi	r18, 0x03	; 3
    7448:	e2 2e       	mov	r14, r18
	
	// Initialize Data Buffer
	resetDataBuffer();
	
    while(1){
        while(!(c = uart_receive())) ;
    744a:	0e 94 e7 38 	call	0x71ce	; 0x71ce <uart_receive>
    744e:	88 23       	and	r24, r24
    7450:	e1 f3       	breq	.-8      	; 0x744a <main+0x78>

        switch(state){
    7452:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
    7456:	93 30       	cpi	r25, 0x03	; 3
    7458:	d1 f1       	breq	.+116    	; 0x74ce <main+0xfc>
    745a:	28 f4       	brcc	.+10     	; 0x7466 <main+0x94>
    745c:	91 30       	cpi	r25, 0x01	; 1
    745e:	61 f0       	breq	.+24     	; 0x7478 <main+0xa6>
    7460:	92 30       	cpi	r25, 0x02	; 2
    7462:	a1 f0       	breq	.+40     	; 0x748c <main+0xba>
    7464:	f2 cf       	rjmp	.-28     	; 0x744a <main+0x78>
    7466:	95 30       	cpi	r25, 0x05	; 5
    7468:	09 f4       	brne	.+2      	; 0x746c <main+0x9a>
    746a:	94 c0       	rjmp	.+296    	; 0x7594 <main+0x1c2>
    746c:	08 f4       	brcc	.+2      	; 0x7470 <main+0x9e>
    746e:	6d c0       	rjmp	.+218    	; 0x754a <main+0x178>
    7470:	96 30       	cpi	r25, 0x06	; 6
    7472:	09 f4       	brne	.+2      	; 0x7476 <main+0xa4>
    7474:	d7 c0       	rjmp	.+430    	; 0x7624 <main+0x252>
    7476:	e9 cf       	rjmp	.-46     	; 0x744a <main+0x78>
            case WAIT_FOR_START:
                if(c == ':'){
    7478:	8a 33       	cpi	r24, 0x3A	; 58
    747a:	39 f7       	brne	.-50     	; 0x744a <main+0x78>
                    uart_send(':');
    747c:	0e 94 59 38 	call	0x70b2	; 0x70b2 <uart_send>
                    // Reset for next state
                    bytesReceived = 0;
    7480:	10 92 ce 01 	sts	0x01CE, r1	; 0x8001ce <bytesReceived>
                    byteSum = 0;
    7484:	10 92 78 02 	sts	0x0278, r1	; 0x800278 <byteSum>
                    state = GET_DATA_LENGTH;
    7488:	82 e0       	ldi	r24, 0x02	; 2
    748a:	5c c0       	rjmp	.+184    	; 0x7544 <main+0x172>
                }    
            break;
            case GET_DATA_LENGTH:
                hexBuffer[bytesReceived++] = c;
    748c:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <bytesReceived>
    7490:	91 e0       	ldi	r25, 0x01	; 1
    7492:	9e 0f       	add	r25, r30
    7494:	90 93 ce 01 	sts	0x01CE, r25	; 0x8001ce <bytesReceived>
    7498:	f0 e0       	ldi	r31, 0x00	; 0
    749a:	e6 53       	subi	r30, 0x36	; 54
    749c:	fe 4f       	sbci	r31, 0xFE	; 254
    749e:	80 83       	st	Z, r24
                uart_send(c);
    74a0:	0e 94 59 38 	call	0x70b2	; 0x70b2 <uart_send>
                if(bytesReceived == 2){
    74a4:	80 91 ce 01 	lds	r24, 0x01CE	; 0x8001ce <bytesReceived>
    74a8:	82 30       	cpi	r24, 0x02	; 2
    74aa:	79 f6       	brne	.-98     	; 0x744a <main+0x78>
                    // Decode data length
                    dataLength = (uint8_t) hexDec(hexBuffer, 2); 
    74ac:	62 e0       	ldi	r22, 0x02	; 2
    74ae:	8a ec       	ldi	r24, 0xCA	; 202
    74b0:	91 e0       	ldi	r25, 0x01	; 1
    74b2:	0e 94 c6 39 	call	0x738c	; 0x738c <hexDec>
    74b6:	80 93 7a 02 	sts	0x027A, r24	; 0x80027a <dataLength>

                    // Add up Bytes for checksum
                    byteSum += dataLength;
    74ba:	90 91 78 02 	lds	r25, 0x0278	; 0x800278 <byteSum>
    74be:	89 0f       	add	r24, r25
    74c0:	80 93 78 02 	sts	0x0278, r24	; 0x800278 <byteSum>

                    // Reset for next state
                    bytesReceived = 0;
    74c4:	10 92 ce 01 	sts	0x01CE, r1	; 0x8001ce <bytesReceived>
                    state = GET_ADDRESS;
    74c8:	e0 92 00 01 	sts	0x0100, r14	; 0x800100 <__DATA_REGION_ORIGIN__>
    74cc:	be cf       	rjmp	.-132    	; 0x744a <main+0x78>
                }
            break;
            case GET_ADDRESS:
                hexBuffer[bytesReceived++] = c;
    74ce:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <bytesReceived>
    74d2:	91 e0       	ldi	r25, 0x01	; 1
    74d4:	9e 0f       	add	r25, r30
    74d6:	90 93 ce 01 	sts	0x01CE, r25	; 0x8001ce <bytesReceived>
    74da:	f0 e0       	ldi	r31, 0x00	; 0
    74dc:	e6 53       	subi	r30, 0x36	; 54
    74de:	fe 4f       	sbci	r31, 0xFE	; 254
    74e0:	80 83       	st	Z, r24
                uart_send(c);
    74e2:	0e 94 59 38 	call	0x70b2	; 0x70b2 <uart_send>
                if(bytesReceived == 4){
    74e6:	80 91 ce 01 	lds	r24, 0x01CE	; 0x8001ce <bytesReceived>
    74ea:	84 30       	cpi	r24, 0x04	; 4
    74ec:	09 f0       	breq	.+2      	; 0x74f0 <main+0x11e>
    74ee:	ad cf       	rjmp	.-166    	; 0x744a <main+0x78>
                    // Decode absolute page address
                    pageAddress = hexDec(hexBuffer, 4);
    74f0:	64 e0       	ldi	r22, 0x04	; 4
    74f2:	8a ec       	ldi	r24, 0xCA	; 202
    74f4:	91 e0       	ldi	r25, 0x01	; 1
    74f6:	0e 94 c6 39 	call	0x738c	; 0x738c <hexDec>
    74fa:	90 93 77 02 	sts	0x0277, r25	; 0x800277 <pageAddress+0x1>
    74fe:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <pageAddress>
                    
                    // Update Checksum
                    byteSum += (uint8_t) pageAddress;
                    byteSum += (uint8_t) (pageAddress >> 8);
    7502:	20 91 78 02 	lds	r18, 0x0278	; 0x800278 <byteSum>
    7506:	28 0f       	add	r18, r24
    7508:	29 0f       	add	r18, r25
    750a:	20 93 78 02 	sts	0x0278, r18	; 0x800278 <byteSum>
                    
                    // Calculate relative page number
                    uint16_t pageNumber = pageAddress / SPM_PAGESIZE;
    750e:	ec 01       	movw	r28, r24
    7510:	cc 0f       	add	r28, r28
    7512:	cd 2f       	mov	r28, r29
    7514:	cc 1f       	adc	r28, r28
    7516:	dd 0b       	sbc	r29, r29
    7518:	d1 95       	neg	r29

                    // Flash old page if page number changes
                    if(pageNumber != currentPage){
    751a:	80 91 c8 01 	lds	r24, 0x01C8	; 0x8001c8 <__data_end>
    751e:	90 91 c9 01 	lds	r25, 0x01C9	; 0x8001c9 <__data_end+0x1>
    7522:	c8 17       	cp	r28, r24
    7524:	d9 07       	cpc	r29, r25
    7526:	59 f0       	breq	.+22     	; 0x753e <main+0x16c>
                        programFlash();
    7528:	0e 94 ad 39 	call	0x735a	; 0x735a <programFlash>
                        currentPage = pageNumber;
    752c:	d0 93 c9 01 	sts	0x01C9, r29	; 0x8001c9 <__data_end+0x1>
    7530:	c0 93 c8 01 	sts	0x01C8, r28	; 0x8001c8 <__data_end>
						dataIndex = pageAddress % SPM_PAGESIZE;
    7534:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <pageAddress>
    7538:	8f 77       	andi	r24, 0x7F	; 127
    753a:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <dataIndex>
                    }

                    // Reset for next state
                    bytesReceived = 0;
    753e:	10 92 ce 01 	sts	0x01CE, r1	; 0x8001ce <bytesReceived>
                    state = GET_RECORD_TYPE;
    7542:	84 e0       	ldi	r24, 0x04	; 4
    7544:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
    7548:	80 cf       	rjmp	.-256    	; 0x744a <main+0x78>
                }
            break;
            case GET_RECORD_TYPE:
                hexBuffer[bytesReceived++] = c;
    754a:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <bytesReceived>
    754e:	91 e0       	ldi	r25, 0x01	; 1
    7550:	9e 0f       	add	r25, r30
    7552:	90 93 ce 01 	sts	0x01CE, r25	; 0x8001ce <bytesReceived>
    7556:	f0 e0       	ldi	r31, 0x00	; 0
    7558:	e6 53       	subi	r30, 0x36	; 54
    755a:	fe 4f       	sbci	r31, 0xFE	; 254
    755c:	80 83       	st	Z, r24
                uart_send(c);
    755e:	0e 94 59 38 	call	0x70b2	; 0x70b2 <uart_send>
                if(bytesReceived == 2){
    7562:	80 91 ce 01 	lds	r24, 0x01CE	; 0x8001ce <bytesReceived>
    7566:	82 30       	cpi	r24, 0x02	; 2
    7568:	09 f0       	breq	.+2      	; 0x756c <main+0x19a>
    756a:	6f cf       	rjmp	.-290    	; 0x744a <main+0x78>
                    // Decode record type
                    recordType = (uint8_t) hexDec(hexBuffer, 2);
    756c:	62 e0       	ldi	r22, 0x02	; 2
    756e:	8a ec       	ldi	r24, 0xCA	; 202
    7570:	91 e0       	ldi	r25, 0x01	; 1
    7572:	0e 94 c6 39 	call	0x738c	; 0x738c <hexDec>
    7576:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <recordType>

                    // Reset for next state
                    byteSum += recordType;
    757a:	90 91 78 02 	lds	r25, 0x0278	; 0x800278 <byteSum>
    757e:	98 0f       	add	r25, r24
    7580:	90 93 78 02 	sts	0x0278, r25	; 0x800278 <byteSum>
                    bytesReceived = 0;
    7584:	10 92 ce 01 	sts	0x01CE, r1	; 0x8001ce <bytesReceived>

                    // Skip GET_DATA state for EOF Records (Type 01)
                    state = (recordType == 1) ? GET_CHECKSUM : GET_DATA;               
    7588:	81 30       	cpi	r24, 0x01	; 1
    758a:	11 f0       	breq	.+4      	; 0x7590 <main+0x1be>
    758c:	85 e0       	ldi	r24, 0x05	; 5
    758e:	da cf       	rjmp	.-76     	; 0x7544 <main+0x172>
    7590:	86 e0       	ldi	r24, 0x06	; 6
    7592:	d8 cf       	rjmp	.-80     	; 0x7544 <main+0x172>
                }
            break;
            case GET_DATA:
                switch (recordType){
    7594:	90 91 f5 01 	lds	r25, 0x01F5	; 0x8001f5 <recordType>
    7598:	91 11       	cpse	r25, r1
    759a:	57 cf       	rjmp	.-338    	; 0x744a <main+0x78>
                case DATA_RECORD:
                    hexBuffer[bytesReceived++] = c;
    759c:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <bytesReceived>
    75a0:	91 e0       	ldi	r25, 0x01	; 1
    75a2:	9e 0f       	add	r25, r30
    75a4:	90 93 ce 01 	sts	0x01CE, r25	; 0x8001ce <bytesReceived>
    75a8:	f0 e0       	ldi	r31, 0x00	; 0
    75aa:	e6 53       	subi	r30, 0x36	; 54
    75ac:	fe 4f       	sbci	r31, 0xFE	; 254
    75ae:	80 83       	st	Z, r24
                    uart_send(c);
    75b0:	0e 94 59 38 	call	0x70b2	; 0x70b2 <uart_send>
                    if(bytesReceived == 2){
    75b4:	80 91 ce 01 	lds	r24, 0x01CE	; 0x8001ce <bytesReceived>
    75b8:	82 30       	cpi	r24, 0x02	; 2
    75ba:	09 f0       	breq	.+2      	; 0x75be <main+0x1ec>
    75bc:	46 cf       	rjmp	.-372    	; 0x744a <main+0x78>
                        // Collect data and add up checksum
                        data[dataIndex] = (uint8_t) hexDec(hexBuffer, 2);
    75be:	c0 91 d0 01 	lds	r28, 0x01D0	; 0x8001d0 <dataIndex>
    75c2:	62 e0       	ldi	r22, 0x02	; 2
    75c4:	8a ec       	ldi	r24, 0xCA	; 202
    75c6:	91 e0       	ldi	r25, 0x01	; 1
    75c8:	0e 94 c6 39 	call	0x738c	; 0x738c <hexDec>
    75cc:	ec 2f       	mov	r30, r28
    75ce:	f0 e0       	ldi	r31, 0x00	; 0
    75d0:	ea 50       	subi	r30, 0x0A	; 10
    75d2:	fe 4f       	sbci	r31, 0xFE	; 254
    75d4:	80 83       	st	Z, r24
                        byteSum += data[dataIndex];
    75d6:	90 91 78 02 	lds	r25, 0x0278	; 0x800278 <byteSum>
    75da:	89 0f       	add	r24, r25
    75dc:	80 93 78 02 	sts	0x0278, r24	; 0x800278 <byteSum>
                        
                        currentDataLength++;	
    75e0:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <currentDataLength>
    75e4:	8f 5f       	subi	r24, 0xFF	; 255
    75e6:	80 93 cf 01 	sts	0x01CF, r24	; 0x8001cf <currentDataLength>
						dataIndex++;
    75ea:	cf 5f       	subi	r28, 0xFF	; 255
    75ec:	c0 93 d0 01 	sts	0x01D0, r28	; 0x8001d0 <dataIndex>
						
						bytesReceived = 0;
    75f0:	10 92 ce 01 	sts	0x01CE, r1	; 0x8001ce <bytesReceived>
						
						if (dataIndex == 128) {
    75f4:	c0 38       	cpi	r28, 0x80	; 128
    75f6:	59 f4       	brne	.+22     	; 0x760e <main+0x23c>
							programFlash();
    75f8:	0e 94 ad 39 	call	0x735a	; 0x735a <programFlash>
							currentPage++;
    75fc:	80 91 c8 01 	lds	r24, 0x01C8	; 0x8001c8 <__data_end>
    7600:	90 91 c9 01 	lds	r25, 0x01C9	; 0x8001c9 <__data_end+0x1>
    7604:	01 96       	adiw	r24, 0x01	; 1
    7606:	90 93 c9 01 	sts	0x01C9, r25	; 0x8001c9 <__data_end+0x1>
    760a:	80 93 c8 01 	sts	0x01C8, r24	; 0x8001c8 <__data_end>
						}
						
                        if(currentDataLength == dataLength){
    760e:	90 91 cf 01 	lds	r25, 0x01CF	; 0x8001cf <currentDataLength>
    7612:	80 91 7a 02 	lds	r24, 0x027A	; 0x80027a <dataLength>
    7616:	98 13       	cpse	r25, r24
    7618:	18 cf       	rjmp	.-464    	; 0x744a <main+0x78>
							currentDataLength = 0;
    761a:	10 92 cf 01 	sts	0x01CF, r1	; 0x8001cf <currentDataLength>
                            state = GET_CHECKSUM;
    761e:	00 93 00 01 	sts	0x0100, r16	; 0x800100 <__DATA_REGION_ORIGIN__>
    7622:	13 cf       	rjmp	.-474    	; 0x744a <main+0x78>
                default:
                    break;
                }
            break;
            case GET_CHECKSUM:
                hexBuffer[bytesReceived++] = c;
    7624:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <bytesReceived>
    7628:	91 e0       	ldi	r25, 0x01	; 1
    762a:	9e 0f       	add	r25, r30
    762c:	90 93 ce 01 	sts	0x01CE, r25	; 0x8001ce <bytesReceived>
    7630:	f0 e0       	ldi	r31, 0x00	; 0
    7632:	e6 53       	subi	r30, 0x36	; 54
    7634:	fe 4f       	sbci	r31, 0xFE	; 254
    7636:	80 83       	st	Z, r24
                uart_send(c);
    7638:	0e 94 59 38 	call	0x70b2	; 0x70b2 <uart_send>
                if(bytesReceived == 2){
    763c:	80 91 ce 01 	lds	r24, 0x01CE	; 0x8001ce <bytesReceived>
    7640:	82 30       	cpi	r24, 0x02	; 2
    7642:	09 f0       	breq	.+2      	; 0x7646 <main+0x274>
    7644:	02 cf       	rjmp	.-508    	; 0x744a <main+0x78>
                    checksum = (uint8_t) hexDec(hexBuffer, 2);
    7646:	62 e0       	ldi	r22, 0x02	; 2
    7648:	8a ec       	ldi	r24, 0xCA	; 202
    764a:	91 e0       	ldi	r25, 0x01	; 1
    764c:	0e 94 c6 39 	call	0x738c	; 0x738c <hexDec>
    7650:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <checksum>
                    
                    // Calculate checksum -> build 2th's complement and check for equality
                    byteSum = ~byteSum + 1;
    7654:	90 91 78 02 	lds	r25, 0x0278	; 0x800278 <byteSum>
    7658:	91 95       	neg	r25
    765a:	90 93 78 02 	sts	0x0278, r25	; 0x800278 <byteSum>
					
					if(byteSum != checksum){
    765e:	89 17       	cp	r24, r25
    7660:	31 f0       	breq	.+12     	; 0x766e <main+0x29c>
						sendString("Checksum mismatch. Please Reset!");
    7662:	87 ea       	ldi	r24, 0xA7	; 167
    7664:	91 e0       	ldi	r25, 0x01	; 1
    7666:	0e 94 12 39 	call	0x7224	; 0x7224 <sendString>
						state = CHECKSUM_ERROR;
    766a:	f0 92 00 01 	sts	0x0100, r15	; 0x800100 <__DATA_REGION_ORIGIN__>
					}
					
					if(recordType == EOF_RECORD){
    766e:	80 91 f5 01 	lds	r24, 0x01F5	; 0x8001f5 <recordType>
    7672:	81 30       	cpi	r24, 0x01	; 1
    7674:	41 f4       	brne	.+16     	; 0x7686 <main+0x2b4>
						// If dataIndex == 0 -> page is empty -> no need to flash
						if(dataIndex != 0){
    7676:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <dataIndex>
    767a:	88 23       	and	r24, r24
    767c:	09 f4       	brne	.+2      	; 0x7680 <main+0x2ae>
    767e:	d3 ce       	rjmp	.-602    	; 0x7426 <main+0x54>
							programFlash();
    7680:	0e 94 ad 39 	call	0x735a	; 0x735a <programFlash>
    7684:	d0 ce       	rjmp	.-608    	; 0x7426 <main+0x54>
						} 
						runProgram();
					}
                    
                    bytesReceived = 0;
    7686:	10 92 ce 01 	sts	0x01CE, r1	; 0x8001ce <bytesReceived>
                    state = WAIT_FOR_START;
    768a:	10 93 00 01 	sts	0x0100, r17	; 0x800100 <__DATA_REGION_ORIGIN__>
                    sendCRLF();
    768e:	0e 94 0c 39 	call	0x7218	; 0x7218 <sendCRLF>
    7692:	db ce       	rjmp	.-586    	; 0x744a <main+0x78>

00007694 <_exit>:
    7694:	f8 94       	cli

00007696 <__stop_program>:
    7696:	ff cf       	rjmp	.-2      	; 0x7696 <__stop_program>
